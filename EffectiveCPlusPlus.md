# 第一章 让自己习惯C++ 
## Item01 视C++为一个语言联邦
C++是一个多重泛型编程语言，同时支持：过程形式、面向对象形式、函数形式、泛型形式和元编程形式。

## Item02 尽量以const,enum,inline替换define
宁可以编译器替代预处理器。  
const常量在编译出错时候提示的是变量名，而define宏在预编译的时候直接替换的，在编译阶段出错只会提示替换后的符号，难以定位问题所在。  
define宏函数可维护性和可读性都比差，其省去函数调用开销的目的，可以用inline函数达到。

总之：  
对于单纯的常量，最好以const对象或enum替换define；  
对于形似函数的宏，最好以inline函数替换define；  

## Item03 尽可能使用const
1. const 出现在星号前面，表示被指物是常量；出现在星号后边，表示指针自身是常量；  
2. const 修饰迭代器，表示迭代器是不可变的（不能指向别的对象了），但是所指向的对象是可以改变的；  

## Item04 确定对象被使用前已被初始化
1. C++ 规定类成员变量的初始化动作发生在进入构造函数体之前（构造函数内部只能称作赋值操作，而不是初始化）。初始化通常效率更高。  
2. 基于赋值的做法，首先调用 default 构造函数为成员变量赋初值，然后再在构造函数内部做赋值操作。  
3. 基类早于子类被初始化，类内部成员变量的初始化顺序与其声明的顺序相同。  
4. staitc 对象的生命周期从构造完开始，直到 main() 函数调用结束。  

注： C++11 下，有三种 thread-safe 的数据初始化形式： 
1. 常量表达式； 
2. 使用 std::once_flag 调用 std::call_once 函数； 
3. 代码块儿内部的 static 变量；  
reference: https://www.modernescpp.com/index.php/thread-safe-initialization-of-data

# 第二章 构造/析构/赋值运算
## Item05 C++ 的默认生成函数
1. 编译器会自动为一个没声明构造函数、析构函数和赋值操作符的类自动生成： default构造函数、析构函数、拷贝构造函数和赋值操作符。


